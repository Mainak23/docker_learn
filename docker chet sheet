FROM rockylinux:9

RUN dnf install -y python3 && dnf clean all

WORKDIR /app
COPY index.html .

EXPOSE 8000
CMD ["python3", "-m", "http.server", "8000","--bind", "0.0.0.0"]

case 2
FROM rockylinux:9

RUN dnf install -y python3 && dnf clean all

WORKDIR /app
COPY test_folder/font_end .-------->inside docker copy everything inside font_end not font_end folder

EXPOSE 8000
CMD ["bash", "-c", "cd html_tag && python3 -m http.server 8000 --bind 0.0.0.0"]















1. Container lifecycle
Image → Created → Running → Paused → Exited → Removed
Image = immutable blueprint
Container = running process + writable layer
PID 1 controls container life
If PID 1 exits → container stops
run = create + start
exec = enter existing container


Containers need:
Read-only image layers
One writable layer
Zero copying
Fast startup
OverlayFS gives a union filesystem.



image comands
podman history my1stimage
podman inspect my1stimage


cointainer commandsd
podman ps
podman ps -a
podman run -it  e14d8cf0c63b (interactive)

volume commands


Build comand
podman build . -t myfirstimage


run comand
podman run -it   -p 8080:8000   b351a8ce3ab6 --------------> 8080 is host post where podman transfer it trafics from 8000 (inside podman port)
podman run -it e14d8cf0c63b bash -c "cd font_end && exec bash"

"""
Why exec bash matters
Replaces subshell
Keeps session alive
Correct PID 1 behavior
"""




path 

FROM rockylinux:9

#RUN dnf install -y python3 && dnf clean all

#WORKDIR /app --->not createing 
COPY test_folder .

EXPOSE 8000

podman run -it 513bfbbac171
[root@54e773483ab7 /]# ls
afs  bin  dev  etc  font_end  home  lib  lib64	lost+found  main.py  media  mnt  opt  proc  root  run  sbin  srv  sys  tmp  usr  var ----> find out file inside test folder not test folder

case 2
FROM rockylinux:9

#RUN dnf install -y python3 && dnf clean all

WORKDIR /app
COPY test_folder .

EXPOSE 8000
CMD ["bash", "-c", "cd font_end && python3 -m http.server 8000 --bind 0.0.0.0"]


Key rule:
Each comma-separated item = one argv element
No shell parsing happens unless you explicitly start a shell

Volume in podman 

Why volumes exist (first principles)
A container is ephemeral.
Container writable layer = temporary
podman rm → all container data is gone
Image layers = read-only
So the problem is:
Where do we keep data that must survive container restarts, upgrades, crashes?
Answer: Volumes (or bind mounts).

Without volume (default behavior)

Image (read-only layers)
↓
Container writable layer (OverlayFS upperdir)

If your app writes to /data:
Data lives in container’s writable layer
Stored in OverlayFS upperdir
When container is removed → data is deleted

OverlayFS
OverlayFS is a Linux kernel filesystem, not a container feature.
Its job:
Merge multiple directories into one virtual filesystem

| Term     | Meaning                            |
| -------- | ---------------------------------- |
| lowerdir | One or more read-only directories  |
| upperdir | Writable directory                 |
| workdir  | Scratch space (required by kernel) |
| merged   | What processes see                 |


ML workloads do:
Large sequential reads (datasets, checkpoints)
Massive small writes (logs, temp files, tensor caches)
Frequent metadata ops (stat, open, close)


How Podman uses OverlayFS
Podman itself does not implement OverlayFS.
Podman only:
Prepares directories
Asks the kernel to mount OverlayFS
Manages lifecycle

OverlayFS is optimized for:
Read-heavy, write-light
App binaries, not data pipelines

OverlayFS is fine for:
Python code
Binaries
Small config files

OverlayFS is bad for:
ML data
Databases
Logs
Anything stateful


With volume (what actually happens)
Example:
podman run -v myvol:/app/data myimage

This means:

Host volume (real filesystem)
        ↑
      mounted
        ↑
Container path /app/data

Important rule (this answers your question directly):
Data is NOT copied into the container.
The container sees the host data directly.

Can you open these files directly?
❌ No
They are:
Binary
Page-based
Engine-version specific
Checksummed and encrypted internally

Where you SHOULD mount container storage (best practice)
❌ Never use
/
/boot
tmpfs

✅ Best locations
Location	When to use
/mnt/docker-data	External disk
/data/containers	Separate internal disk
/srv/containers	Server-standard layout






When you should NOT use containers for DBs
If:
Single server
One SQL Server instance
Stable schema
No frequent redeployments
No CI/CD
Bare-metal performance matters

When containerized DB makes sense for you
Use Podman/Docker if:
You want clean rollback
You want staging/prod parity
You deploy frequently
You plan Kubernetes later
You want infra discipline
Don’t use it if:
One DB
Rare changes
Performance is king
No automation










#####################3
podman build --help

http://localhost:8080/

Full Podman reset (containers + images + networks + cache)
podman system reset -f
####################

Multi-stage 
Multi-stage builds are mandatory in prod
Single-stage images = amateur
Smaller images = faster deploy + safer
If you need bash in runtime, rethink design














